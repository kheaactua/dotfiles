#!/bin/bash

# Give xrandr and i3wm a moment to settle after the display change
sleep 0.5

# --- Log file settings ---
declare -r LOG_FILE="/tmp/i3_autorandr_debug.log"
declare -r MAX_LOG_LINES=10 # Keep only the last 50 lines in the log file

# --- Define Monitor Identification Criteria ---
# These values MUST match your xrandr --verbose output exactly.

# Left display (First in Daisy Chain)
declare -r LEFT_DISPLAY_RES="1920x1200"

# Central Non-Daisy-Chained Monitor
declare -r CENTER_DISPLAY_RES="2560x1080"

# Right display (Second in Daisy Chain)
declare -r RIGHT_DISPLAY_RES="1200x1920"

# Function to get all xrandr output names (e.g., DisplayPort-5)
# for monitors matching specific resolution.
# Returns a newline-separated list of matching outputs.
get_all_outputs_by_resolution() {
  local target_res_awk="$1"
  xrandr --verbose | awk -v target_res="$target_res_awk" '
    # Look for lines like "DisplayPort-1 connected primary 2560x1080+0+0 ..."
    /^[A-Za-z0-9_-]+ connected/ {
      current_output = $1; # e.g., "DisplayPort-1"

      # Extract resolution (e.g., "2560x1080") from the line
      # This regex looks for "WIDTHxHEIGHT+OFFSETX+OFFSETY" and extracts "WIDTHxHEIGHT"
      match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/, res_offset_arr);
      current_res = substr(res_offset_arr[0], 1, index(res_offset_arr[0], "+") - 1);

      # Compare with target resolution
      if (current_res == target_res) {
        print current_output;
      }
    }
  '
}


# --- Identify Current Outputs ---
declare -r LEFT_DISPLAY_OUTPUT="$(get_all_outputs_by_resolution "${LEFT_DISPLAY_RES}" | head -n 1)"
declare -r CENTER_DISPLAY_OUTPUT=$(get_all_outputs_by_resolution "${CENTER_DISPLAY_RES}" | head -n 1)
declare -r RIGHT_DISPLAY_OUTPUT="$(get_all_outputs_by_resolution "${RIGHT_DISPLAY_RES}" | head -n 1)"

# --- Debugging: Writes detected outputs to a log file ---
# Check the log file if things don't work as expected.
echo "--- $(date) ---" >> ${LOG_FILE}
echo "Left (Daisy):  ${LEFT_DISPLAY_OUTPUT}"   >> ${LOG_FILE}
echo "Central:       ${CENTER_DISPLAY_OUTPUT}" >> ${LOG_FILE}
echo "Right (Daisy): ${RIGHT_DISPLAY_OUTPUT}"  >> ${LOG_FILE}

# Now, trim the log file to MAX_LOG_LINES
tail -n "${MAX_LOG_LINES}" "${LOG_FILE}" > "${LOG_FILE}.tmp" && mv "${LOG_FILE}.tmp" "${LOG_FILE}"

# --- Move your workspaces to their correct outputs ---
# Adjust workspace numbers and target outputs as per your preference.
# Only try to move if the output was actually detected.

declare -a i3_workspaces=($(i3-msg -t get_workspaces | jq '.[].num'))

move_workspace_to_output() {
  local workspace_number="$1"
  local output_name="$2"

  local output

  if [[ ! " ${i3_workspaces[@]} " =~ " ${workspace_number} " ]]; then
    echo "Workspace ${workspace_number} does not exist, skipping move." >> "${LOG_FILE}"
    return
  fi

  # TODO I think this actually uses the name, not the number
  if [ -n "${output_name}" ]; then
    output=$(i3-msg [workspace=${workspace_number}] move workspace to output ${output_name} 2>/dev/null)
    echo "i3-msg '[workspace=${workspace_number}]' move workspace to output ${output_name} â†’ ${output}" >> "${LOG_FILE}"
  else
    echo "No output detected for workspace ${workspace_number}, skipping move." >> "${LOG_FILE}"
  fi
}

# Assign workspaces to displays
if [ -n "${LEFT_DISPLAY_OUTPUT}" ]; then
  for i in 1 8; do
    move_workspace_to_output "${i}" "${LEFT_DISPLAY_OUTPUT}"
  done
fi

if [ -n "${CENTER_DISPLAY_OUTPUT}" ]; then
  for i in 2 4 5 6 7 9 10; do
    move_workspace_to_output "${i}" "${CENTER_DISPLAY_OUTPUT}"
  done
fi

if [ -n "${RIGHT_DISPLAY_OUTPUT}" ]; then
  for i in 3 11 12; do
    move_workspace_to_output "${i}" "${RIGHT_DISPLAY_OUTPUT}"
  done
fi

# Optional: Focus on a specific workspace after the move
# i3-msg "workspace 1"

# vim: ft=sh
